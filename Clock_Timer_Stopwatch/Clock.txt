module clock(
    seg_out,
    am_pm,
    led_out,
    load_input1,
    load_input2,
    load_input3,
    CLK100MHZ,
    reset,
    an
);
    input CLK100MHZ, reset;
    input [5:0] load_input1, load_input2;
    input [3:0] load_input3;
    output [6:0] seg_out;
    output reg [3:0] an;
    output reg [11:0] led_out;
    output am_pm;

    wire clk_out;
    wire [1:0] count;
    wire [5:0] sec_1, min_1;
    wire [3:0] hours_1;
    reg [3:0] tens, units, tens_1, units_1;
    wire display_clk;

    // Frequency divider to create a 1 Hz clock from 100 MHz
    freq fq(.clk_in(CLK100MHZ), .clk_out(clk_out));
    display_clock_divider display_clk_div(.clk_in(CLK100MHZ), .clk_out(display_clk));

    // Counter module
    count cn(
        .clk(clk_out),
        .rst(reset),
        .sec(sec_1),
        .min(min_1),
        .hours(hours_1),
        .load_input1(load_input1),
        .load_input2(load_input2),
        .load_input3(load_input3),
        .am_pm(am_pm)
    );

    // 4-bit multiplexing counter
    count_4 cnn(.clk(display_clk), .rst(reset), .count(count));

    // Update BCD values for display
    always @(*) begin
        tens = sec_1 / 10;
        units = sec_1 % 10;
        tens_1 = min_1 / 10;
        units_1 = min_1 % 10;
    end

    // LED output logic for hours
    always @(*) begin
        led_out = 12'b0; // Reset all LEDs
        if (hours_1 > 0 && hours_1 <= 12) begin
            for (integer i = 0; i < hours_1; i = i + 1) begin
                led_out[i] = 1;
            end
        end
    end

    // Multiplexing logic for seven-segment display
    reg [3:0] bcd;
    always @(posedge display_clk) begin
        if (reset) begin
            an = 4'b1111;
            bcd = 4'b0000;
        end else begin
            case (count)
                2'b00: begin
                    an = 4'b0111;
                    bcd = tens_1; // Tens of minutes
                end
                2'b01: begin
                    an = 4'b1011;
                    bcd = units_1; // Units of minutes
                end
                2'b10: begin
                    an = 4'b1101;
                    bcd = tens; // Tens of seconds
                end
                2'b11: begin
                    an = 4'b1110;
                    bcd = units; // Units of seconds
                end
                default: begin
                    an = 4'b1111;
                    bcd = 4'b0000;
                end
            endcase
        end
    end

    // Seven-segment display decoder
    seven_segment ssg(.seg(seg_out), .in(bcd));
endmodule

// Frequency Divider
module freq(clk_in, clk_out);
    input clk_in;
    output reg clk_out;
    reg [26:0] counter;

    initial begin
        clk_out = 0;
        counter = 0;
    end

    always @(posedge clk_in) begin
        if (counter ==50000000) begin
            counter <= 0;
            clk_out <= ~clk_out;
        end else begin
            counter <= counter + 1;
        end
    end
endmodule

// Display Clock Divider
module display_clock_divider(input wire clk_in, output reg clk_out);
    reg [16:0] counter;
    always @(posedge clk_in) begin
        if (counter == 10000) begin
            clk_out <= ~clk_out;
            counter <= 0;
        end else begin
            counter <= counter + 1;
        end
    end
endmodule

// 4-bit counter for multiplexing
module count_4(input clk, rst, output reg [1:0] count);
    always @(posedge clk) begin
        if (rst) begin
            count <= 2'b00;
        end else if (count == 2'b11) begin
            count <= 2'b00;
        end else begin
            count <= count + 1;
        end
    end
endmodule

// Counter Module
module count(
    input clk,rst,
    input [5:0] load_input1,load_input2,
    input [3:0] load_input3,
    output reg [5:0] sec,min,
    output reg [3:0] hours,
    output reg am_pm
);
    always @(posedge clk) begin
        if (rst) begin
            sec <= (load_input1 < 60) ? load_input1 : 0;
            min <= (load_input2 < 60) ? load_input2 : 0;
            hours <= (load_input3 > 0 && load_input3 <= 12) ? load_input3 : 0;
            am_pm <= 0; // Default to AM
        end else if (sec == 59) begin
            sec <= 0;
            if (min == 59) begin
                min <= 0;
                if (hours == 11) begin
                    hours <= 12;
                    am_pm <= ~am_pm;
                end else if (hours == 12) begin
                    hours <= 1;
                end else begin
                    hours <= hours + 1;
                end
            end else begin
                min <= min + 1;
            end
        end else begin
            sec <= sec + 1;
        end
    end
endmodule

// Seven-Segment Display Decoder
module seven_segment(seg, in);
    input [3:0] in;
    output reg [6:0] seg;
    always @(*) begin
        case (in)
            4'b0000: seg = 7'b1000000; // 0
            4'b0001: seg = 7'b1111001; // 1
            4'b0010: seg = 7'b0100100; // 2
            4'b0011: seg = 7'b0110000; // 3
            4'b0100: seg = 7'b0011001; // 4
            4'b0101: seg = 7'b0010010; // 5
            4'b0110: seg = 7'b0000010; // 6
            4'b0111: seg = 7'b1111000; // 7
            4'b1000: seg = 7'b0000000; // 8
            4'b1001: seg = 7'b0010000; // 9
            default: seg = 7'b1111111; // Off
        endcase
    end
endmodule

