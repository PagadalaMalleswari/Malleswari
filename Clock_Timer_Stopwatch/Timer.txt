module timer(
    f_seg_out,
    f_led_out,
    f_load_input1,
    f_load_input2,
    f_load_input3,
    f_CLK100MHZ,
    f_reset,
    f_an
);
    input f_CLK100MHZ, f_reset;
    input [5:0] f_load_input1, f_load_input2;
    input [3:0]f_load_input3;
    output [6:0] f_seg_out;
    output reg [3:0] f_an;
    output reg [11:0] f_led_out;
   

    wire f_clk_out;
    wire [1:0] f_count;
    wire [5:0] f_sec_1, f_min_1;
    wire [3:0] f_hours_1;
    reg [3:0] tens, units, tens_1, units_1;
    wire f_display_clk;
    wire f_stop;

    // Frequency divider to create a 1 Hz clock from 100 MHz
    freq1 fq(.clk_in(f_CLK100MHZ), .clk_out(f_clk_out));
    display_clock_divider1 display_clk_div(.clk_in(f_CLK100MHZ), .clk_out(f_display_clk));

    // Counter module
    count1 cnn(
        .clk(f_clk_out),
        .rst(f_reset),
        .sec(f_sec_1),
        .min(f_min_1),
        .hours(f_hours_1),
        .load_input1(f_load_input1),
        .load_input2(f_load_input2),
        .load_input3(f_load_input3),
       .stop(f_stop));

    // 4-bit multiplexing counter
    count_41 cn(.clk(f_display_clk), .rst(f_reset), .count(f_count));
    // LED output logic for hours
    always @(*) begin
        f_led_out = 12'b0; // Reset all LEDs
        if (f_hours_1 > 0 && f_hours_1 <= 12) begin
            for (integer i = 0; i < f_hours_1; i = i + 1) begin
               f_led_out[i] = 1;
            end
        end
    end


    // Update BCD values for display
    always @(*) begin
    if(f_stop) 
    begin
        tens =12;
        units = 13;
        tens_1 = 10;
        units_1 = 11;
    end
    
    else
   begin
        tens =f_sec_1 / 10;
        units = f_sec_1 % 10;
        tens_1 = f_min_1 / 10;
        units_1 = f_min_1 % 10;
    end
end

    // Multiplexing logic for seven-segment display
    reg [3:0] bcd;
    always @(posedge f_display_clk) begin
        if (f_reset) begin
            f_an = 4'b1111;
            bcd = 4'b0000;
        end else begin
            case (f_count)
                2'b00: begin
                    f_an = 4'b0111;
                    bcd = tens_1; // Tens of minutes
                end
                2'b01: begin
                    f_an = 4'b1011;
                    bcd = units_1; // Units of minutes
                end
                2'b10: begin
                    f_an = 4'b1101;
                    bcd = tens; // Tens of seconds
                end
                2'b11: begin
                   f_an = 4'b1110;
                    bcd = units; // Units of seconds
                end
                default: begin
                    f_an = 4'b1111;
                    bcd = 4'b0000;
                end
            endcase
        end
    end

    // Seven-segment display decoder
    seven_segment1 ssg(.seg(f_seg_out), .in(bcd));
endmodule

// Frequency Divider
module freq1(clk_in, clk_out);
    input clk_in;
    output reg clk_out;
    reg [26:0] counter;

    initial begin
        clk_out = 0;
        counter = 0;
    end

    always @(posedge clk_in) begin
        if (counter ==50000000) begin
            counter <= 0;
            clk_out <= ~clk_out;
        end else begin
            counter <= counter + 1;
        end
    end
endmodule

// Display Clock Divider
module display_clock_divider1(input wire clk_in, output reg clk_out);
    reg [16:0] counter;
    always @(posedge clk_in) begin
        if (counter == 10000) begin
            clk_out <= ~clk_out;
            counter <= 0;
        end else begin
            counter <= counter + 1;
        end
    end
endmodule

// 4-bit counter for multiplexing
module count_41(input clk, rst, output reg [1:0] count);
    always @(posedge clk) begin
        if (rst) begin
            count <= 2'b00;
        end else if (count == 2'b11) begin
            count <= 2'b00;
        end else begin
            count <= count + 1;
        end
    end
endmodule

//timer Counter Module
module count1(
    input clk,rst,
    input [5:0] load_input1,load_input2,
    input [3:0] load_input3,
    output reg [5:0] sec,min,
    output reg [3:0] hours,output reg stop);
    always @(posedge clk) begin
        if (rst) begin
            sec <= (load_input1 < 60) ? load_input1 : 0;
            min <= (load_input2 < 60) ? load_input2 : 0;
            hours <= (load_input3 >=0 && load_input3 <= 12) ? load_input3 : 0;
            stop<=0;
        end else if (sec == 0) begin
            sec = 59;
            if (min == 0) begin
                min = 59;
                if (hours ==0) begin
                    stop=1;
                   
                end else begin
                    hours <= hours - 1;
                end
            end else begin
                min <= min - 1;
            end
        end else begin
            sec <= sec - 1;
        end
    end
endmodule

// Seven-Segment Display Decoder
module seven_segment1(seg, in);
    input [3:0] in;
    output reg [6:0] seg;
    always @(*) begin
        case (in)
            4'b0000: seg = 7'b1000000; // 0
            4'b0001: seg = 7'b1111001; // 1
            4'b0010: seg = 7'b0100100; // 2
            4'b0011: seg = 7'b0110000; // 3
            4'b0100: seg = 7'b0011001; // 4
            4'b0101: seg = 7'b0010010; // 5
            4'b0110: seg = 7'b0000010; // 6
            4'b0111: seg = 7'b1111000; // 7
            4'b1000: seg = 7'b0000000; // 8
            4'b1001: seg = 7'b0010000; // 9
            4'b1010: seg = 7'b0010010; // s
            4'b1011: seg = 7'b0000111; // t
            4'b1100: seg = 7'b1000000; // o
            4'b1101: seg = 7'b0001100; // p
            default: seg = 7'b1111111; // Off
        endcase
    end
endmodule